#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>

#define sigmoid(x) (1.0 / (1.0 + exp(-x)));
#define relu(x) x >= 0 ? x : x/10.0;

typedef unsigned char BYTE;

typedef struct tagMNIST_DATA
{
	BYTE *pixels;
	BYTE label;
} MNIST, *pMNIST;

void forward_calculation(MNIST *data, double *computed_hidden, double *computed_output);
void weight_initialization(double *weight, int row, int column); 
void print_weight(double* weight, int row, int column); 
void ann_testing();
void ann_training();
int little_to_big_endian(FILE *fd); 
MNIST* data_reader(MNIST *data_set, char *data_file, char *label_file, BYTE file_type); 

const double LEARNING_RATE = 0.1;
const int NUM_OF_INPUT = 28*28;
const int NUM_OF_HIDDEN = 15;
const int NUM_OF_OUTPUT = 10;

int test_size;
int training_size;

int data_rows;
int data_columns;

double *weight_hidden;
double *weight_output;

MNIST *training_data;
MNIST *test_data;

int timer = 2;
int epoches = 10;

void 
forward_calculation(MNIST *data, double *computed_hidden, double *computed_output)
{
	int i, j;
	double min = 999999;
	double max = -999999;
	
	for(i=0; i<NUM_OF_HIDDEN; i++)
	{
		computed_hidden[i] = 0;

		for(j=0; j<NUM_OF_INPUT; j++)
		{
			computed_hidden[i] += weight_hidden[NUM_OF_INPUT*i+j] 
					* ((double)data->pixels[j]/255.0);
		}
		/*
		printf("hidden: %lf", computed_hidden[i]);
		computed_hidden[i] = sigmoid(computed_hidden[i]);
		computed_hidden[i] = relu(computed_hidden[i]);
		printf("\t%lf\t%lf\n", computed_hidden[i], weight_output[i]);
		*/
	}

	for(i=0; i<NUM_OF_HIDDEN; i++)
	{
		if(computed_hidden[i] > max)
			max = computed_hidden[i];
		if(computed_hidden[i] < min)
			min = computed_hidden[i];
	}

	for(i=0; i<NUM_OF_HIDDEN; i++)
	{
		printf("hidden: %lf", computed_hidden[i]);
		computed_hidden[i] = ((computed_hidden[i] - min) / (max - min) -0.5) * 20.0;
		computed_hidden[i] = sigmoid(computed_hidden[i]);
		printf("\t%lf\t%lf\n", computed_hidden[i], weight_output[i]);
	}
	// Calculate Hidden

	//printf("----------------------------------------------------------\n");

	min = 999999;
	max = -999999;

	for(i=0; i<NUM_OF_OUTPUT; i++)
	{
		computed_output[i] = 0;

		for(j=0; j<NUM_OF_HIDDEN; j++)
		{
			computed_output[i] += weight_output[NUM_OF_HIDDEN*i+j] 
					* computed_hidden[j];
		}
		/*
		printf("output: %lf", computed_output[i]);
		computed_output[i] = sigmoid(computed_output[i]);
		computed_output[i] = relu(computed_output[i]);
		printf("\t%lf\n", computed_output[i]);
		*/
	}
	for(i=0; i<NUM_OF_OUTPUT; i++)
	{
		if(computed_output[i] > max)
			max = computed_output[i];
		if(computed_output[i] < min)
			min = computed_output[i];
	}

	for(i=0; i<NUM_OF_OUTPUT; i++)
	{
		printf("output: %lf", computed_output[i]);
		computed_output[i] = ((computed_output[i] - min) / (max - min) -0.5) * 20.0;
		computed_output[i] = sigmoid(computed_output[i]);
		printf("\t%lf\n", computed_output[i]);
	}
	// Calculate Output
	
	// printf("\n");
}

void
weight_initialization(double *weight, int row, int column) 
{
	int i,j;
	srand(time(NULL));

	for(i=0; i<row; i++)
		for(j=0; j<column; j++)
			weight[i*column + j] = (double)rand() / (double)RAND_MAX;
}

void
print_weight(double* weight, int row, int column) 
{
	int i, j;

	for(i=0; i<row; i++)
	{
		printf("-- weight %d\n", i);
		for(j=0; j<column; j++)
		{
			printf("\t%5d: %lf\n", j, weight[column*i + j]);
		}
	}
}

void
ann_testing()
{
        double *computed_hidden = (double *)malloc(NUM_OF_HIDDEN * sizeof(double));
        double *computed_output = (double *)malloc(NUM_OF_OUTPUT * sizeof(double));

        int correct = 0;
        int wrong = 0;

        int i, j;
        for(i=0; i<test_size; i++)
        {
                forward_calculation((test_data+i), computed_hidden, computed_output);

                int classification = -1;
                double max_value = -999999;

                for(j=0; j<NUM_OF_OUTPUT; j++)
                {
                        if(computed_output[j] > max_value)
                        {
                        //      printf("changed on %d\n", j);
                                max_value = computed_output[j];
                                classification = j;
                        }
                        printf("%d:%lf\n", j, computed_output[j]);
                }
                printf("%d ==> %d, Answer is %d\n", i, classification, (test_data+i)->label);

                if(classification == ((test_data+i)->label))
                        correct++;
                else
                        wrong++;
        }

        printf("--Score--\n");
        printf("\tcorrect:\t%d/%d\n", correct, test_size);
        printf("\twrong:\t%d/%d\n", wrong, test_size);
        printf("\tAccuracy:\t%.3lf\n", (double)correct/(double)test_size);

        free(computed_hidden);
        free(computed_output);
}

void 
ann_training() 
{
	weight_hidden = (double *)malloc(NUM_OF_INPUT * NUM_OF_HIDDEN * sizeof(double));
	weight_output = (double *)malloc(NUM_OF_HIDDEN * NUM_OF_OUTPUT * sizeof(double));

	double *error_hidden = (double *)malloc(NUM_OF_HIDDEN * sizeof(double));
	double *error_output = (double *)malloc(NUM_OF_OUTPUT * sizeof(double));
	
	double *computed_hidden = (double *)malloc(NUM_OF_HIDDEN * sizeof(double));	
	double *computed_output = (double *)malloc(NUM_OF_OUTPUT * sizeof(double));

	weight_initialization(weight_hidden, NUM_OF_HIDDEN, NUM_OF_INPUT);
	weight_initialization(weight_output, NUM_OF_OUTPUT, NUM_OF_HIDDEN);

	print_weight(weight_output, NUM_OF_OUTPUT, NUM_OF_HIDDEN);
	
	int i, j, k, l;
	for(i=0; i<epoches; i++)
	{
		for(j=0; j<training_size; j++)
		{
			int label = (training_data+j)->label;
			// get training data's class

			forward_calculation((training_data+j), computed_hidden, computed_output);

			for(k=0; k<NUM_OF_OUTPUT; k++) 
			{
				error_output[k] = computed_output[k] * (1 - computed_output[k]) 
							* (label - computed_output[k]);
			}
			// delta k

			for(k=0; k<NUM_OF_HIDDEN; k++)
			{
				double sum = 0.0;

				for(l=0; l<NUM_OF_OUTPUT; l++)
					sum += weight_output[NUM_OF_OUTPUT*l + k] * error_output[l];

				error_hidden[k] = computed_hidden[k] * (1-computed_hidden[k]) * sum;
			}
			// delta h

			for(k=0; k<NUM_OF_OUTPUT; k++) 
			{
				for(l=0; l<NUM_OF_HIDDEN; l++) 
				{
					weight_output[NUM_OF_HIDDEN*k + l] += LEARNING_RATE 
						* error_output[k] * computed_hidden[l];
				}
			}

			for(k=0; k<NUM_OF_HIDDEN; k++) 
			{
				for(l=0; l<NUM_OF_INPUT; l++)
				{
					weight_hidden[NUM_OF_INPUT*k + l] += LEARNING_RATE 
						* error_hidden[k] 
						* ((double)(training_data+j)->pixels[l]/255.0);
				}
			}

			sleep(timer);
		}
		printf("epoch: %d\n", i);
	}

	//print_weight(weight_output, NUM_OF_OUTPUT, NUM_OF_HIDDEN);
	
	free(error_hidden);
	free(error_output);

	free(computed_hidden);
	free(computed_output);
}

int 
little_to_big_endian(FILE *fd) 
{
	BYTE *reader = (BYTE *)malloc(sizeof(BYTE)*4);
	fread(reader, sizeof(int), 1, fd);
	return (int)reader[3] | (int)reader[2]<<8 
				| (int)reader[1]<<16 | (int)reader[0]<<24;
} 

MNIST*
data_reader(MNIST *data_set, char *data_file, char *label_file, BYTE file_type) 
{
	FILE *f_data = fopen(data_file, "rb");
	FILE *f_label = fopen(label_file, "rb");

	if(!f_data || !f_label) 
	{
		printf("[Error code -1] %s file not exist!!\n", !f_data ? data_file : label_file);
		exit(-1);
	}

	int d_magic, l_magic;
	int num_of_data, num_of_label;
	
	d_magic = little_to_big_endian(f_data);
	l_magic = little_to_big_endian(f_label);

	if(d_magic != 2051 || l_magic != 2049)
	{
		printf("[Error code -2] This file isn't a MNIST file!\n");
		printf("\t\tMagic Number[data:%d, label:%d]\n", d_magic, l_magic);
		exit(-2);
	}

	num_of_data = little_to_big_endian(f_data);
	num_of_label = little_to_big_endian(f_label);

	if(num_of_data != num_of_label)
	{
		printf("[Error code -3] Number of data is not equal number of label\n");
		printf("\t\t Num of data: %d, Num of label: %d\n", num_of_data, num_of_label);
		exit(-3);
	}

	data_rows = little_to_big_endian(f_data);
	data_columns = little_to_big_endian(f_data);

	if(file_type == 0)	training_size = num_of_data;
	else			test_size = num_of_data;

	data_set = (MNIST *)malloc(sizeof(MNIST) * num_of_data);

	BYTE *data = (BYTE *)malloc(sizeof(BYTE));

	int i, j, k;
	for(i=0; i<num_of_data; i++)
	{
		fread(&((data_set+i)->label), sizeof(BYTE), 1, f_label);
	
		((data_set+i)->pixels) = (BYTE *)malloc(sizeof(BYTE) * data_rows * data_columns);
		for(j=0; j<data_rows; j++)
		{
			for(k=0; k<data_columns; k++)
			{
				fread(data, sizeof(BYTE), 1, f_data);
				(data_set+i)->pixels[j*data_columns + k] = *data;
			}
		}	
	}

	free(data);

	fclose(f_data);
	fclose(f_label);

	return data_set;
}

int 
main(int argc, char* argv) 
{
	char *tr_data = "MNIST/train-images.idx3-ubyte";
	char *tr_label = "MNIST/train-labels.idx1-ubyte";

	char *ts_data = "MNIST/t10k-images.idx3-ubyte";
	char *ts_label = "MNIST/t10k-labels.idx1-ubyte";

	training_data = data_reader(training_data, tr_data, tr_label, 0);
	test_data = data_reader(test_data, ts_data, ts_label, 1);

	ann_training();
	printf("Training Complete!!\n");

	ann_testing();

	free(training_data);
	free(test_data);

	return 0;
}
